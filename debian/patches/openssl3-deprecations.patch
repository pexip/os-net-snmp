diff --git a/include/net-snmp/library/cert_util.h b/include/net-snmp/library/cert_util.h
index 80e2a19..ec7b5ba 100644
--- a/include/net-snmp/library/cert_util.h
+++ b/include/net-snmp/library/cert_util.h
@@ -2,10 +2,10 @@
 
 #if defined(NETSNMP_USE_OPENSSL) && defined(HAVE_LIBSSL)
 
-#ifndef HEADER_SSL_H
+#ifndef OPENSSL_SSL_H
 #error "must include <openssl/ssl.h> before cert_util.h"
 #endif
-#ifndef HEADER_X509_H
+#ifndef OPENSSL_X509_H
 #error "must include <openssl/x509.h> before cert_util.h"
 #endif
 
diff --git a/snmplib/snmp_api.c b/snmplib/snmp_api.c
index 79c28aa..bd8c76d 100644
--- a/snmplib/snmp_api.c
+++ b/snmplib/snmp_api.c
@@ -138,6 +138,7 @@ SOFTWARE.
 #include <net-snmp/library/vacm.h>
 #if defined(NETSNMP_USE_OPENSSL) && defined(HAVE_LIBSSL)
 #include <openssl/ssl.h>
+#include <openssl/x509.h>
 #include <net-snmp/library/cert_util.h>
 #endif
 
diff --git a/snmplib/transports/snmpDTLSUDPDomain.c b/snmplib/transports/snmpDTLSUDPDomain.c
index c7032e6..58fd55a 100644
--- a/snmplib/transports/snmpDTLSUDPDomain.c
+++ b/snmplib/transports/snmpDTLSUDPDomain.c
@@ -75,6 +75,7 @@ netsnmp_feature_require(sockaddr_size);
 #include "openssl/ssl.h"
 #include "openssl/err.h"
 #include "openssl/rand.h"
+#include "openssl/x509.h"
 
 #include <net-snmp/library/snmpSocketBaseDomain.h>
 #include <net-snmp/library/snmpTLSBaseDomain.h>
diff --git a/snmplib/transports/snmpTLSBaseDomain.c b/snmplib/transports/snmpTLSBaseDomain.c
index 1a907b4..127f658 100644
--- a/snmplib/transports/snmpTLSBaseDomain.c
+++ b/snmplib/transports/snmpTLSBaseDomain.c
@@ -223,7 +223,11 @@ netsnmp_tlsbase_verify_server_cert(SSL *ssl, _netsnmpTLSBaseData *tlsdata) {
     netsnmp_assert_or_return(ssl != NULL, SNMPERR_GENERR);
     netsnmp_assert_or_return(tlsdata != NULL, SNMPERR_GENERR);
 
+#if OPENSSL_VERSION_NUMBER < 0x30000000L
     remote_cert = SSL_get_peer_certificate(ssl);
+#else
+    remote_cert = SSL_get1_peer_certificate(ssl);
+#endif
     if (!remote_cert) {
         /* no peer cert */
         DEBUGMSGTL(("tls_x509:verify",
@@ -354,7 +358,11 @@ netsnmp_tlsbase_verify_client_cert(SSL *ssl, _netsnmpTLSBaseData *tlsdata) {
          above.
        + fingerprint verification happens below.
     */
+#if OPENSSL_VERSION_NUMBER < 0x30000000L
     remote_cert = SSL_get_peer_certificate(ssl);
+#else
+    remote_cert = SSL_get1_peer_certificate(ssl);
+#endif
     if (!remote_cert) {
         /* no peer cert */
         DEBUGMSGTL(("tls_x509:verify",
diff --git a/snmplib/transports/snmpTLSTCPDomain.c b/snmplib/transports/snmpTLSTCPDomain.c
index ea5423f..0c46dd4 100644
--- a/snmplib/transports/snmpTLSTCPDomain.c
+++ b/snmplib/transports/snmpTLSTCPDomain.c
@@ -51,6 +51,11 @@ netsnmp_feature_require(cert_util);
 
 #include "../memcheck.h"
 
+#include "openssl/bio.h"
+#include "openssl/ssl.h"
+#include "openssl/err.h"
+#include "openssl/x509.h"
+
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
@@ -65,10 +70,6 @@ netsnmp_feature_require(cert_util);
 #include <net-snmp/library/snmp_openssl.h>
 #include <net-snmp/library/callback.h>
 
-#include "openssl/bio.h"
-#include "openssl/ssl.h"
-#include "openssl/err.h"
-
 #ifndef INADDR_NONE
 #define INADDR_NONE	-1
 #endif
diff --git a/snmplib/snmp_openssl.c b/snmplib/snmp_openssl.c
index 4110b0e..e1ce9b5 100644
--- a/snmplib/snmp_openssl.c
+++ b/snmplib/snmp_openssl.c
@@ -21,6 +21,9 @@
 #if defined(NETSNMP_USE_OPENSSL)
 
 #include <string.h>
+#include <openssl/opensslv.h>
+
+#if OPENSSL_VERSION_NUMBER < 0x30000000L
 #include <openssl/dh.h>
 
 #ifndef HAVE_DH_GET0_PQG
@@ -78,6 +81,7 @@ DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g)
    return 1;
 }
 #endif
+#endif /* OPENSSL_VERSION_NUMBER < 0x30000000L */
 #endif /* defined(NETSNMP_USE_OPENSSL) */
 
 /** TLS/DTLS certificatte support */
@@ -697,7 +701,11 @@ netsnmp_openssl_get_cert_chain(SSL *ssl)
 
     netsnmp_assert_or_return(ssl != NULL, NULL);
 
+#if OPENSSL_VERSION_NUMBER < 0x30000000L
     ocert = SSL_get_peer_certificate(ssl);
+#else
+    ocert = SSL_get1_peer_certificate(ssl);
+#endif
     if (!ocert) {
         /** no peer cert */
         snmp_log(LOG_ERR, "SSL peer has no certificate\n");
@@ -736,7 +744,11 @@ netsnmp_openssl_get_cert_chain(SSL *ssl)
 
     /** check for a chain to a CA */
     ochain = SSL_get_peer_cert_chain(ssl);
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     sk_num_res = sk_num((const void *)ochain);
+#else
+    sk_num_res = OPENSSL_sk_num((const void *)ochain);
+#endif
     if (!ochain || sk_num_res == 0) {
         DEBUGMSGT(("ssl:cert:chain", "peer has no cert chain\n"));
     }
@@ -745,9 +757,17 @@ netsnmp_openssl_get_cert_chain(SSL *ssl)
          * loop over chain, adding fingerprint / cert for each
          */
         DEBUGMSGT(("ssl:cert:chain", "examining cert chain\n"));
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
         sk_num_res = sk_num((const void *)ochain);
+#else
+        sk_num_res = OPENSSL_sk_num((const void *)ochain);
+#endif
         for(i = 0; i < sk_num_res; ++i) {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
             ocert_tmp = (X509*)sk_value((const void *)ochain,i);
+#else
+            ocert_tmp = (X509*)OPENSSL_sk_value((const void *)ochain,i);
+#endif
             fingerprint = netsnmp_openssl_cert_get_fingerprint(ocert_tmp, -1);
             if (NULL == fingerprint)
                 break;
diff --git a/snmplib/snmpusm.c b/snmplib/snmpusm.c
index 75fc952..3696a86 100644
--- a/snmplib/snmpusm.c
+++ b/snmplib/snmpusm.c
@@ -767,6 +767,7 @@ usm_free_user(struct usmUser *user)
     }
 
 #ifdef NETSNMP_USE_OPENSSL
+#if OPENSSL_VERSION_NUMBER < 0x30000000L
     if (user->usmDHUserAuthKeyChange)
     {
         DH_free(user->usmDHUserAuthKeyChange);
@@ -778,6 +779,7 @@ usm_free_user(struct usmUser *user)
         DH_free(user->usmDHUserPrivKeyChange);
         user->usmDHUserPrivKeyChange = NULL;
     }
+#endif
 #endif
 
     /*
--- a/apps/snmpusm.c	2021-08-02 14:25:09.067239181 +0000
+++ b/apps/snmpusm.c	2021-08-02 15:23:33.343662094 +0000
@@ -21,6 +21,7 @@
 #include <net-snmp/library/snmp_openssl.h>
 #if defined(HAVE_OPENSSL_DH_H) && defined(HAVE_LIBCRYPTO)
 #include <openssl/dh.h>
+#include <openssl/evp.h>
 #endif /* HAVE_OPENSSL_DH_H && HAVE_LIBCRYPTO */
 
 #if HAVE_STDLIB_H
@@ -180,15 +181,259 @@
 }
 
 #if defined(HAVE_OPENSSL_DH_H) && defined(HAVE_LIBCRYPTO)
+#if (OPENSSL_VERSION_NUMBER < 0x30000000L)
+
+#define OSSL_LIB_CTX void
+#define OSSL_PKEY_PARAM_PUB_KEY "pub"
+#define OSSL_PKEY_PARAM_PRIV_KEY "priv"
+#define OSSL_PKEY_PARAM_FFC_P "p"
+#define OSSL_PKEY_PARAM_FFC_Q "q"
+#define OSSL_PKEY_PARAM_FFC_G "g"
+
+typedef struct {
+    char *name;
+    BIGNUM *value;
+} OSSL_PARAM;
+
+typedef struct {
+    OSSL_PARAM *params;
+    size_t n_params;
+} OSSL_PARAM_BLD;
+
+static OSSL_PARAM_BLD *OSSL_PARAM_BLD_new(void)
+{
+    return calloc(1, sizeof(OSSL_PARAM_BLD));
+}
+
+static void OSSL_PARAM_BLD_free(OSSL_PARAM_BLD *bld)
+{
+    size_t idx;
+
+    if (bld == NULL)
+        return;
+
+    for (idx = 0; idx < bld->n_params; idx++) {
+        free(bld->params[idx].name);
+        BN_free(bld->params[idx].value);
+    }
+
+    free(bld);
+}
+
+static int OSSL_PARAM_BLD_push_BN(OSSL_PARAM_BLD *bld,
+                                  const char *key_name,
+                                  const BIGNUM *bn)
+{
+    OSSL_PARAM *params;
+    int rc = 0;
+
+    if (bld->params == NULL)
+        params = calloc(1, sizeof(OSSL_PARAM));
+    else
+        params = realloc(bld->params, (bld->n_params + 1) * sizeof(OSSL_PARAM));
+
+    if (params != NULL) {
+        bld->params = params;
+        params[bld->n_params].name = strdup(key_name);
+        if (params[bld->n_params].name == NULL) {
+            params[bld->n_params].value = NULL;
+        } else {
+            params[bld->n_params].value = BN_dup(bn);
+            if (params[bld->n_params].value == NULL) {
+                free(params[bld->n_params].name);
+                params[bld->n_params].name = NULL;
+            } else {
+                bld->n_params += 1;
+                rc = 1;
+            }
+        }
+    }
+
+    return rc;
+}
+
+static OSSL_PARAM *OSSL_PARAM_BLD_to_param(OSSL_PARAM_BLD *bld)
+{
+    OSSL_PARAM *params;
+    size_t idx;
+
+    params = calloc(bld->n_params + 1, sizeof(OSSL_PARAM));
+    if (params != NULL) {
+        for (idx = 0; idx < bld->n_params; idx++) {
+            params[idx].name = strdup(bld->params[idx].name);
+            if (params[idx].name != NULL) {
+                params[idx].value = BN_dup(bld->params[idx].value);
+                if (params[idx].value == NULL) {
+                    free(params[idx].name);
+                    break;
+                }
+            } else {
+                break;
+            }
+        }
+        if (idx != bld->n_params) {
+            /* Failed to copy: clean up */
+            size_t didx;
+            for (didx = 0; didx < idx; didx++) {
+                free(params[didx].name);
+                BN_free(params[didx].value);
+            }
+            free(params);
+           params = NULL;
+        }
+    }
+
+    return params;
+}
+
+static void OSSL_PARAM_free(OSSL_PARAM *param)
+{
+    OSSL_PARAM *p;
+
+    for (p = param; p != NULL && p->name != NULL; p++) {
+        free(p->name);
+        if (p->value != NULL)
+            BN_free(p->value);
+    }
+
+    free(param);
+}
+
+static EVP_PKEY_CTX *EVP_PKEY_CTX_new_from_name(OSSL_LIB_CTX *libctx,
+                                                const char *name,
+                                                const char *propquery)
+{
+    assert(libctx == NULL && propquery == NULL);
+    assert(strcmp(name, "DH") == 0);
+    return EVP_PKEY_CTX_new_id(EVP_PKEY_DH, NULL);
+}
+
+static int EVP_PKEY_fromdata_init(EVP_PKEY_CTX *ctx)
+{
+    return 1;
+}
+
+#define EVP_PKEY_KEY_PARAMETERS 0x01
+#define EVP_PKEY_PUBLIC_KEY (EVP_PKEY_KEY_PARAMETERS | 0x02)
+#define EVP_PKEY_KEYPAIR (EVP_PKEY_PUBLIC_KEY | 0x04)
+static int EVP_PKEY_fromdata(EVP_PKEY_CTX *ctx,
+                             EVP_PKEY **pkey,
+                             int selection,
+                             OSSL_PARAM params[])
+{
+    OSSL_PARAM *p;
+    DH *dh;
+    EVP_PKEY *result;
+
+    dh = DH_new();
+    if (dh == NULL)
+        return 0;
+
+    for (p = params; p != NULL && p->name != NULL; p++) {
+        if (selection & 0x1) {
+            if (strcmp(p->name, OSSL_PKEY_PARAM_FFC_P) == 0) {
+                DH_set0_pqg(dh, p->value, NULL, NULL);
+               p->value = NULL;
+            } else if (strcmp(p->name, OSSL_PKEY_PARAM_FFC_Q) == 0) {
+                DH_set0_pqg(dh, NULL, p->value, NULL);
+               p->value = NULL;
+            } else if (strcmp(p->name, OSSL_PKEY_PARAM_FFC_G) == 0) {
+                DH_set0_pqg(dh, NULL, NULL, p->value);
+               p->value = NULL;
+            }
+        }
+        if (selection & 0x2) {
+            if (strcmp(p->name, OSSL_PKEY_PARAM_PUB_KEY) == 0) {
+                DH_set0_key(dh, p->value, NULL);
+               p->value = NULL;
+            }
+        }
+        if (selection & 0x4) {
+            if (strcmp(p->name, OSSL_PKEY_PARAM_PRIV_KEY) == 0) {
+                DH_set0_key(dh, NULL, p->value);
+               p->value = NULL;
+            }
+        }
+    }
+
+    pkey = EVP_PKEY_new();
+    if (pkey == NULL) {
+        DH_free(dh);
+       return 0;
+    }
+    EVP_PKEY_assign_DH(pkey, dh);
+
+    return 1;
+}
+
+static int EVP_PKEY_get_bn_param(const EVP_PKEY *pkey,
+				 const char *key_name,
+				 BIGNUM **bn)
+{
+	DH *dh = EVP_PKEY_get1_DH(pkey);
+	const BIGNUM *val = NULL;
+	int rc = 0;
+
+	if (dh != NULL) {
+		if (strcmp(key_name, OSSL_PKEY_PARAM_PUB_KEY) == 0) {
+			DH_get0_key(dh, &val, NULL);
+		} else if (strcmp(key_name, OSSL_PKEY_PARAM_FFC_P) == 0) {
+			DH_get0_pqg(dh, &val, NULL, NULL);
+		} else if (strcmp(key_name, OSSL_PKEY_PARAM_FFC_Q) == 0) {
+			DH_get0_pqg(dh, NULL, &val, NULL);
+		} else if (strcmp(key_name, OSSL_PKEY_PARAM_FFC_G) == 0) {
+			DH_get0_pqg(dh, NULL, NULL, &val);
+		}
+
+		if (val != NULL) {
+			*bn = BN_dup(val);
+			rc = 1;
+		}
+
+		DH_free(dh);
+	}
+
+	return rc;
+}
+
+static EVP_PKEY *d2i_KeyParams(int type, EVP_PKEY **a, const unsigned char **pp,
+			       long length)
+{
+	DH *dh;
+	EVP_PKEY *pkey;
+
+	if (type != EVP_PKEY_DH)
+		return NULL;
+	dh = d2i_DHparams(NULL, pp, length);
+	if (dh == NULL)
+		return NULL;
+	pkey = EVP_PKEY_new();
+	if (pkey == NULL) {
+		DH_free(dh);
+		return NULL;
+	}
+	EVP_PKEY_assign_DH(pkey, dh);
+	if (a != NULL)
+		*a = pkey;
+	return pkey;
+}
+
+#else
+#include <openssl/core_names.h>
+#include <openssl/param_build.h>
+#endif
+
 int
 get_USM_DH_key(netsnmp_variable_list *vars, netsnmp_variable_list *dhvar,
                size_t outkey_len,
                netsnmp_pdu *pdu, const char *keyname,
                oid *keyoid, size_t keyoid_len) {
     u_char *dhkeychange;
-    DH *dh;
-    const BIGNUM *p, *g, *pub_key;
-    BIGNUM *other_pub;
+    OSSL_PARAM_BLD *bld = NULL;
+    OSSL_PARAM *params = NULL;
+    EVP_PKEY *dhparams, *dh, *peer_key;
+    EVP_PKEY_CTX *pctx;
+    BIGNUM *p = NULL, *g = NULL, *pub_key = NULL, *other_pub = NULL;
     u_char *key;
     size_t key_len;
             
@@ -198,26 +453,94 @@
     
     memcpy(dhkeychange, vars->val.string, vars->val_len);
 
+    other_pub = BN_bin2bn(vars->val.string, vars->val_len, NULL);
+    if (!other_pub) {
+        SNMP_FREE(dhkeychange);
+        return SNMPERR_GENERR;
+    }
+
+    bld = OSSL_PARAM_BLD_new();
+    if (bld == NULL) {
+        BN_free(other_pub);
+        SNMP_FREE(dhkeychange);
+        return SNMPERR_GENERR;
+    }
+    if (OSSL_PARAM_BLD_push_BN(bld,
+                               OSSL_PKEY_PARAM_PUB_KEY,
+                               other_pub) == 0) {
+        OSSL_PARAM_BLD_free(bld);
+        BN_free(other_pub);
+        SNMP_FREE(dhkeychange);
+        return SNMPERR_GENERR;
+    }
+    params = OSSL_PARAM_BLD_to_param(bld);
+    if (params == NULL) {
+        OSSL_PARAM_BLD_free(bld);
+        BN_free(other_pub);
+        SNMP_FREE(dhkeychange);
+        return SNMPERR_GENERR;
+    }
+    pctx = EVP_PKEY_CTX_new_from_name(NULL, "DH", NULL);
+    if (pctx == NULL || EVP_PKEY_fromdata_init(pctx) <= 0 ||
+            EVP_PKEY_fromdata(pctx, &peer_key, EVP_PKEY_PUBLIC_KEY, params) <= 0) {
+        if (pctx) EVP_PKEY_CTX_free(pctx);
+        OSSL_PARAM_free(params);
+        OSSL_PARAM_BLD_free(bld);
+        BN_free(other_pub);
+        SNMP_FREE(dhkeychange);
+        return SNMPERR_GENERR;
+    }
+    EVP_PKEY_CTX_free(pctx);
+    OSSL_PARAM_free(params);
+    OSSL_PARAM_BLD_free(bld);
+    BN_free(other_pub);
+
     {
         const unsigned char *cp = dhvar->val.string;
-        dh = d2i_DHparams(NULL, &cp, dhvar->val_len);
+        dhparams = d2i_KeyParams(EVP_PKEY_DH, NULL, &cp, dhvar->val_len);
     }
 
-    if (dh)
-        DH_get0_pqg(dh, &p, NULL, &g);
+    if (!dhparams ||
+            EVP_PKEY_get_bn_param(dhparams, OSSL_PKEY_PARAM_FFC_P, &p) == 0 ||
+	    EVP_PKEY_get_bn_param(dhparams, OSSL_PKEY_PARAM_FFC_G, &g) == 0) {
+        if (p) BN_free(p);
+        if (dhparams) EVP_PKEY_free(dhparams);
+        EVP_PKEY_free(peer_key);
+        SNMP_FREE(dhkeychange);
+        return SNMPERR_GENERR;
+    }
+    BN_free(g);
+    BN_free(p);
 
-    if (!dh || !g || !p) {
+    pctx = EVP_PKEY_CTX_new(dhparams, NULL);
+    if (pctx == NULL) {
+        EVP_PKEY_free(dhparams);
+        EVP_PKEY_free(peer_key);
         SNMP_FREE(dhkeychange);
         return SNMPERR_GENERR;
     }
 
-    if (!DH_generate_key(dh)) {
+    if (EVP_PKEY_keygen_init(pctx) <= 0 || EVP_PKEY_keygen(pctx, &dh) <= 0) {
+        EVP_PKEY_CTX_free(pctx);
+        EVP_PKEY_free(dhparams);
+        EVP_PKEY_free(peer_key);
+        SNMP_FREE(dhkeychange);
+        return SNMPERR_GENERR;
+    }
+    EVP_PKEY_CTX_free(pctx);
+    EVP_PKEY_free(dhparams);
+
+    if (EVP_PKEY_get_bn_param(dh, OSSL_PKEY_PARAM_PUB_KEY, &pub_key) == 0) {
+        EVP_PKEY_free(dh);
+        EVP_PKEY_free(peer_key);
         SNMP_FREE(dhkeychange);
         return SNMPERR_GENERR;
     }
 
-    DH_get0_key(dh, &pub_key, NULL);
     if (vars->val_len != (unsigned int)BN_num_bytes(pub_key)) {
+        BN_free(pub_key);
+        EVP_PKEY_free(dh);
+        EVP_PKEY_free(peer_key);
         SNMP_FREE(dhkeychange);
         fprintf(stderr,"incorrect diffie-helman lengths (%lu != %d)\n",
                 (unsigned long)vars->val_len, BN_num_bytes(pub_key));
@@ -225,27 +538,41 @@
     }
 
     BN_bn2bin(pub_key, dhkeychange + vars->val_len);
+    BN_free(pub_key);
 
-    key_len = DH_size(dh);
-    if (!key_len) {
+    pctx = EVP_PKEY_CTX_new(dh, NULL);
+    if (pctx == NULL) {
+        EVP_PKEY_free(dh);
+        EVP_PKEY_free(peer_key);
         SNMP_FREE(dhkeychange);
         return SNMPERR_GENERR;
     }
-    key = (u_char *) malloc(key_len * sizeof(u_char));
-
-    if (!key) {
+    if (EVP_PKEY_derive_init(pctx) <= 0 ||
+            EVP_PKEY_derive_set_peer(pctx, peer_key) <= 0) {
+        EVP_PKEY_CTX_free(pctx);
+        EVP_PKEY_free(dh);
+        EVP_PKEY_free(peer_key);
+        SNMP_FREE(dhkeychange);
+        return SNMPERR_GENERR;
+    }
+    EVP_PKEY_free(peer_key);
+    if (EVP_PKEY_derive(pctx, NULL, &key_len) <= 0) {
+        EVP_PKEY_CTX_free(pctx);
+        EVP_PKEY_free(dh);
         SNMP_FREE(dhkeychange);
         return SNMPERR_GENERR;
     }
 
-    other_pub = BN_bin2bn(vars->val.string, vars->val_len, NULL);
-    if (!other_pub) {
+    key = (u_char *) malloc(key_len * sizeof(u_char));
+
+    if (!key) {
+        EVP_PKEY_CTX_free(pctx);
+        EVP_PKEY_free(dh);
         SNMP_FREE(dhkeychange);
-        SNMP_FREE(key);
         return SNMPERR_GENERR;
     }
 
-    if (DH_compute_key(key, other_pub, dh)) {
+    if (EVP_PKEY_derive(pctx, key, &key_len) == 1) {
         u_char *kp;
 
         printf("new %s key: 0x", keyname);
@@ -255,14 +582,15 @@
         }
         printf("\n");
     }
+    EVP_PKEY_CTX_free(pctx);
+    EVP_PKEY_free(dh);
 
     snmp_pdu_add_variable(pdu, keyoid, keyoid_len,
                           ASN_OCTET_STR, dhkeychange,
                           2 * vars->val_len);
 
-    SNMP_FREE(dhkeychange);
-    SNMP_FREE(other_pub);
     SNMP_FREE(key);
+    SNMP_FREE(dhkeychange);
 
     return SNMPERR_SUCCESS;
 }
